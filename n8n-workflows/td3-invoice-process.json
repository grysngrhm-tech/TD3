{
  "name": "TD3 Invoice Extraction v4",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "td3-invoice-process",
        "responseMode": "lastNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [220, 300],
      "webhookId": "td3-invoice-process"
    },
    {
      "parameters": {
        "method": "GET",
        "url": "={{ $json.fileUrl }}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "file"
            }
          }
        }
      },
      "id": "download-invoice",
      "name": "Download Invoice File",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [440, 300],
      "continueOnFail": true
    },
    {
      "parameters": {
        "resource": "file",
        "binaryPropertyName": "data",
        "options": {
          "purpose": "user_data"
        }
      },
      "id": "upload-to-openai",
      "name": "Upload to OpenAI Files",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 2,
      "position": [660, 300],
      "credentials": {
        "openAiApi": {
          "id": "openai-credentials",
          "name": "OpenAi account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "amount": 3
      },
      "id": "wait-for-processing",
      "name": "Wait",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [880, 300],
      "webhookId": "td3-invoice-wait"
    },
    {
      "parameters": {
        "jsCode": "// Build request body for OpenAI Responses API - EXTRACTION ONLY\nconst fileId = $input.first().json.id;\nconst webhookData = $('Webhook').first().json;\n\n// Check if file upload succeeded\nif (!fileId) {\n  return [{\n    json: {\n      error: true,\n      invoiceId: webhookData.invoiceId,\n      message: 'Failed to upload file to OpenAI'\n    }\n  }];\n}\n\n// Extraction-only prompt - structured signals for deterministic matching\nconst prompt = `You are extracting structured data from a construction invoice for automated matching.\nDO NOT include raw line items. Instead, create semantic context from them.\n\nReturn ONLY a valid JSON object with this exact structure:\n\n{\n  \"vendor_name\": \"Company name on invoice\",\n  \"invoice_number\": \"Invoice ID or null if not found\",\n  \"invoice_date\": \"YYYY-MM-DD or null if not found\",\n  \"amount\": 0.00,\n  \n  \"context\": \"Brief semantic description of work performed, e.g., 'Electrical panel upgrade and wiring installation for 200amp service'\",\n  \n  \"keywords\": [\"electrical\", \"panel\", \"wiring\", \"200amp\", \"service\", \"breaker\"],\n  \n  \"trade\": \"electrical\",\n  \n  \"work_type\": \"mixed\",\n  \n  \"vendor_type\": \"subcontractor\",\n  \n  \"project_reference\": \"Lot 42 or null\",\n  \n  \"has_lien_waiver\": false,\n  \n  \"confidence\": 0.95\n}\n\nFIELD INSTRUCTIONS:\n\n- vendor_name: The company name that issued the invoice\n- invoice_number: Invoice number/ID, or null if not found\n- invoice_date: Date in YYYY-MM-DD format, or null if not found  \n- amount: Total amount as a number (no currency symbols)\n\n- context: One sentence summarizing the work/materials - extract meaning from line items, DO NOT list them\n- keywords: 5-10 normalized lowercase keywords extracted from line items describing work/materials\n\n- trade: One of these values or null if unclear:\n  \"electrical\" | \"plumbing\" | \"hvac\" | \"framing\" | \"roofing\" | \"flooring\" | \n  \"foundation\" | \"excavation\" | \"landscaping\" | \"painting\" | \"drywall\" | \n  \"insulation\" | \"windows_doors\" | \"appliances\" | \"fixtures\" | \"general\"\n\n- work_type: \"labor\" | \"materials\" | \"equipment\" | \"mixed\"\n\n- vendor_type: \"subcontractor\" | \"supplier\" | \"utility\" | \"professional\" | \"unknown\"\n\n- project_reference: Any project code, lot number, or address mentioned, or null\n\n- has_lien_waiver: true if a lien waiver is mentioned/attached, false otherwise\n\n- confidence: 0.0-1.0 - how confident are you in this extraction?\n\nIf you cannot determine a value, use null. For amount, extract the numeric total only.`;\n\nconst body = {\n  model: \"gpt-4o-mini\",\n  input: [\n    {\n      role: \"user\",\n      content: [\n        {\n          type: \"input_text\",\n          text: prompt\n        },\n        {\n          type: \"input_file\",\n          file_id: fileId\n        }\n      ]\n    }\n  ],\n  text: {\n    format: {\n      type: \"json_object\"\n    }\n  }\n};\n\nreturn [{\n  json: {\n    body,\n    invoiceId: webhookData.invoiceId,\n    fileName: webhookData.fileName,\n    drawRequestId: webhookData.drawRequestId,\n    projectId: webhookData.projectId\n  }\n}];"
      },
      "id": "build-responses-body",
      "name": "Build Responses Body",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1100, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/responses",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "openAiApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.body }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "call-openai-responses",
      "name": "Call OpenAI Responses",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1320, 300],
      "credentials": {
        "openAiApi": {
          "id": "openai-credentials",
          "name": "OpenAi account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Parse OpenAI Responses API output and extract invoice data\nconst input = $input.first().json;\nconst prevData = $('Build Responses Body').first().json;\n\n// Check for errors\nif (input.error || !input.output) {\n  return [{\n    json: {\n      error: true,\n      invoiceId: prevData.invoiceId,\n      message: input.error?.message || 'OpenAI API call failed'\n    }\n  }];\n}\n\n// Parse the response\nlet extractedInvoice = {};\ntry {\n  const content = input.output?.[0]?.content?.[0]?.text || '';\n  if (typeof content === 'string') {\n    // Remove any markdown code blocks if present\n    const jsonStr = content.replace(/```json\\n?|```\\n?/g, '').trim();\n    extractedInvoice = JSON.parse(jsonStr);\n  }\n} catch (e) {\n  return [{\n    json: {\n      error: true,\n      invoiceId: prevData.invoiceId,\n      message: 'Failed to parse OpenAI response: ' + e.message\n    }\n  }];\n}\n\n// Return extracted data (matching will be done by TD3 application)\nreturn [{\n  json: {\n    invoiceId: prevData.invoiceId,\n    fileName: prevData.fileName,\n    drawRequestId: prevData.drawRequestId,\n    projectId: prevData.projectId,\n    extractedInvoice\n  }\n}];"
      },
      "id": "parse-openai-response",
      "name": "Parse OpenAI Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1540, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "check-error",
              "leftValue": "={{ $json.error }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-extraction-error",
      "name": "Check Extraction Error",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1760, 300]
    },
    {
      "parameters": {
        "jsCode": "// Build callback payload with extraction data only\n// Matching will be done by the TD3 application using deterministic logic\nconst prevData = $input.first().json;\nconst extracted = prevData.extractedInvoice || {};\n\n// Normalize the extracted data to our expected format\nconst extractedData = {\n  vendorName: extracted.vendor_name || 'Unknown Vendor',\n  invoiceNumber: extracted.invoice_number || null,\n  invoiceDate: extracted.invoice_date || null,\n  amount: parseFloat(extracted.amount) || 0,\n  \n  // New semantic extraction fields\n  context: extracted.context || null,\n  keywords: Array.isArray(extracted.keywords) ? extracted.keywords : [],\n  trade: extracted.trade || null,\n  workType: extracted.work_type || null,\n  vendorType: extracted.vendor_type || null,\n  projectReference: extracted.project_reference || null,\n  hasLienWaiver: extracted.has_lien_waiver === true,\n  confidence: parseFloat(extracted.confidence) || 0\n};\n\n// Build callback payload - extraction only, no matching\nreturn [{\n  json: {\n    invoiceId: prevData.invoiceId,\n    n8nExecutionId: $execution.id,\n    success: true,\n    extractedData,\n    // Include metadata for the callback handler\n    metadata: {\n      drawRequestId: prevData.drawRequestId,\n      projectId: prevData.projectId,\n      fileName: prevData.fileName\n    }\n  }\n}];"
      },
      "id": "build-callback-payload",
      "name": "Build Callback Payload",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1980, 200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $('Webhook').first().json.callbackUrl || ($env.TD3_API_URL + '/api/invoices/process-callback') }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "X-TD3-Webhook-Secret",
              "value": "={{ $env.TD3_WEBHOOK_SECRET }}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json) }}",
        "options": {
          "timeout": 10000
        }
      },
      "id": "success-callback",
      "name": "Success Callback",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2200, 200],
      "continueOnFail": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $('Webhook').first().json.callbackUrl || ($env.TD3_API_URL + '/api/invoices/process-callback') }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "X-TD3-Webhook-Secret",
              "value": "={{ $env.TD3_WEBHOOK_SECRET }}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ invoiceId: $json.invoiceId, n8nExecutionId: $execution.id, success: false, error: $json.message || 'Extraction failed' }) }}",
        "options": {
          "timeout": 10000
        }
      },
      "id": "error-callback",
      "name": "Error Callback",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1980, 480],
      "continueOnFail": true
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ received: true, invoiceId: $('Webhook').first().json.invoiceId, status: 'processing' }) }}"
      },
      "id": "respond-webhook",
      "name": "Respond",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [2420, 300]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Download Invoice File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download Invoice File": {
      "main": [
        [
          {
            "node": "Upload to OpenAI Files",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload to OpenAI Files": {
      "main": [
        [
          {
            "node": "Wait",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait": {
      "main": [
        [
          {
            "node": "Build Responses Body",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Responses Body": {
      "main": [
        [
          {
            "node": "Call OpenAI Responses",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call OpenAI Responses": {
      "main": [
        [
          {
            "node": "Parse OpenAI Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse OpenAI Response": {
      "main": [
        [
          {
            "node": "Check Extraction Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Extraction Error": {
      "main": [
        [
          {
            "node": "Error Callback",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Callback Payload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Callback Payload": {
      "main": [
        [
          {
            "node": "Success Callback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Success Callback": {
      "main": [
        [
          {
            "node": "Respond",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Callback": {
      "main": [
        [
          {
            "node": "Respond",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "name": "TD3",
      "createdAt": "2024-01-01T00:00:00.000Z",
      "updatedAt": "2024-01-01T00:00:00.000Z"
    }
  ]
}
